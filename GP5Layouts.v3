// General file format for a GuitarPro5 file
layout struct _filelayout() for "GP5"{
	def array_size(cda: Array<chord_diagram>){
		int sum = 0;
		for (cd in cda){
			sum += cd._size();
		}
		return sum;
	}
	def _size(){
		return header._size() + body._size() + 4 + array_size(chord_diagrams);
	}
	+0B			header:				Header;
	__			body:				Body;
	__			chord_diagram_count:		int;
	__			chord_diagrams:			Array<chord_diagram>;
	=_size();
}

layout struct GPcolor for "GP5"{
// Color component in GP5
	+0B			white:				byte = 0x00;
	+1B			red:				byte;
	+2B			green:				byte;
	+3B			blue:				byte;
	=4B
}

layout struct byteSizeString(K: u32) for "GP5"{
// TODO: GP string is a special primitive type, maybe add a syntax
// for defining file-specific primitive types
	def _size(){
		return K + 1;
	}
	+0B			size:				byte = K;
	+1B			chars:				char[K];
	=_size();
}

layout struct intSizeString(K: u32) for "GP5"{
	def _size(){
		return K + 4;
	}
 = K;
	+1B			chars:				char[K];
	=_size();
}


// Layout structures related to header
layout struct piece_information for "GP5"{
	def _size(){
		int sum = 0;
		// TODO: We may want define special methods to traverse through all components
		// in a structure to allow convenient check of size
		// ALTERNATIVELY: _size() of a structrure is by default calculate in that way
		for (cmpnt: header.component){
			sum += cmpnt._size();
		}
		return _size();
	}
	+0B			title:				byteSizedString;
	// Again, we don't know the precies location of each string, and
	// it will be redundant if we specify all parameters, the best practice seems
	// to be let the parser call _size() for each component and then compute the offset
	__			subtitle:			byteSizedString;
	__			interpret:			byteSizedString;
	__			album:				byteSizedString;
	__			author:				byteSizedString;
	__			copyright:			byteSizedString;
	__			tablature_author:		byteSizedString;
	__			instructional_line:		byteSizedString;
	__			notes_cnt:			int = notes_count;
	__			notes:				byteSizedString[notes_count];
	=_size();
}

layout struct lyric_line for "GP5"{
// A signle lyric line
	def _size(){
		return starting_measure + str._size();
	}
	// The starting measure of the lyric line
	+0B			starting_measure:		int;
	// The text of the line of lyrics
	+4B			str:				byteSizedString;
	=_size();
}

layout struct lyrics for "GP5"{
// the lyrics section, including five lyric lines generated by GP
	def _size(){
		int sum = 0;
		for (i = 0; i <= 5; i++){
			sum += lrc_lines[i]._size();
		}
		return sum;
	}
	// Number of track the lyrics bound with 
	+0B			num_tracks:			int;
	// Five lines of lyrics 
	+4B			lrc_lines:			lyric_line[5];
	=_size();
}

layout struct midi_channels for "GP5"{
// Used only by other_information struct
	+0B			instrument:			int;
	+4B			volume:				byte;
	+5B			balance:			byte;
	+6B			chorus:				byte;
	+7B			reverb:				byte;
	+8B			phaser:				byte;
	+9B			tremolo:			byte;
	// Two blank bytes are for compatability with version 3.0
	+10B			blank1:				byte;
	+11B			blank2:				byte;
	=12B
}

layout struct other_information for "GP5"{
// The fourth component of header, fixed size of 26 byte
	+0B			tempo:				int;
	+4B			key:				byte;
	+5B			octave:				byte;
	// The midi channels component
	+6B			md_chns:			midi_channels;
	+18B			num_measures:			int;
	+22B			num_tracks:			int;
	=26B
}

layout struct Header(d_size: byte, notes_count: int) for "GP5"{
	// TODO: as what is done in everParse3D, we may want to add a verifier
	// the verifier checks if certain requirements are ensured
	def _verifier(){
		return _size() == d_size + 30;
	}
	def _size(){
		int sum = 0;
		for (cmpnt: header.component){
			sum += cmpnt._size();
		}
		return _size();
	}
	// A 30-byte lengthed string for guitarpro file version
	+0B			version:			byteSizedString(30);
	// A block of data containing information about the piece
	+31B			d_size:				byte = data_size;
	+32B			pc_info:			piece_information;
	__			lyrc:				lyrics;
	__			other_info:			other_information;
	=_size();
}


// Layout structures related to the body of the file
layout struct marker(K: u32) for "GP5"{
	def _size(){
		return 9 + K;
	}
	// The length of the marker name
	+0B			name_len:			int = K + 1;
	// Marker name
	+4B			name:				byteSizedString(K);
	+4B + K + 1		color:				GPcolor;
	=_size();
}

layout struct measure for "GP5"{
// The measures are written one after another, their number having been specified previously
	// The first byte is the measure's header: it lists the data given in the current measure
	def _size(){
		return 6 + mkr._size();
	}
	+0B			header:				byte;
	// Numerator of the (key) signature of the piece
	+1B			sig_numerator:			byte;
	// Denominator of the (key) signature of the piece
	+2B			sig_denom:			byte;
	// Number of repeats until the previous Beginning of repeat.
	+3B			end_of_repeat:			byte;
	// The number of alternate ending
	+4B			num_alternate_ending:		byte;
	// A marker
	+5B			mkr:				marker;
	__			totality:			byte;
	=_size();
}

layout struct tracks for "GP5"{
	+0B			header:				byte;
	// A 40 characters long string containing the track's name
	+1B			str:				byteSizedString(40);
	// An integer equal to the number of strings of the track.
	+42B			num_str:			int;
	// The tuning of the strings is stored as a 7-integers table
	+70B			tuning_strs:			int[7];
	// Number of midi ports
	+74B			port:				int;
	// Number of midi channels used
	+78B			channel:			int;
	// Number of midi channels used for effects
	+82B			channelE:			int;
	// Number of frets of the instrument
	+86B			num_of_frets:			int;
	// The number of the fret on which a capo is present. If no capo is used, the value is 0x00000000
	+90B			capo_height:			int;
	+94B			track_color:			GPcolor;
	=98B;
}

layout struct measure_beat_track for "GP5"{
// The measure_beat_track is an array of integers, however, for modularity
// we define a component for it so that it can be conveniently inserted in the
// structure "body".
	def _size(){
		int sum = 0;
		for (beat in mt_beats){
			sum += beat.length;
		}
		return sum;
	}
	+0B			mt_beats:			Array<int>;
	=_size();
}

layout struct chord_diagram for "GP5"{
	def _size(){
		return 128;
	}
	+0B			header:				byte = 0x01;
	// Determines whether the chord is sharp or flat
	+1B			sharp:				byte;
	+2B			blanks:				byte[3];
	+5B			root:				byte;
	+6B			major_minor:			byte;
	// Determines if the chord goes until the ninth, the eleventh, or the thirteenth
	+7B			n_e_t:				byte;
	+8B			bass:				int;
	// 0: perfect, 1: agumented, 2: diminished
	+12B			dimi_aug:			int;
	// Determines if a 'add' (added note) is present in the chord
	+16B			add:				byte;
	+17B			name:				byteSizedString(20);
	+38B			blanks2:			byte[2];
	// The tonaility of the fifth, ninth, and eleventh 
	+40B			fifth:				byte;
	// Shows the fret from which the chord is displayed
	+41B			base_fret:			int;
	// Corresponds to the fret number played on each string, from the highest to the lowest
	+45B			frets:				int[7];
	// Indicates the number of barres there are in the chord. A chord can contain up to 5 barres
	+73B			num_barres:			byte;
	// Indicates the fret number of each possible barre
	+74B			fret_barres:			int[5];
	// Indicates the first string of the barre, 1 being the highest
	+79B			barres_start:			int[5];
	// Indicates the first string of the barre, 1 being the lowest
	+84B			barres_end:			int[5];
	// Gives the notes there are in the chord for 1, 3, 5, 7, 9, 11, 13
	+89B			omissions:			byte[7];
	// Blank byte needed for ascendant compatibility with versions 3 of the software
	+98B			blank6:				byte;
	// Describes the fingering used to play the chord
	+99B			fingering:			int[7];
	// If it is 0x01, the chord fingering is displayed
	// If it is 0x00, the chord fingering is masked
	+127B			show_dia_fin:			byte;
	=_size();
}

layout struct point for "GP5"{
	// Gives the point position from the previous point. This value goes between 0 and 60
        // and represents sixties of the note duration
	+0B			abs_time:			int;
	// Vertical position: It is 100 per tone and goes by quarter tone
	+4B			vert_pos:			int;
	// Determines how to play the section, with different vibrato types
	+8B			vibrato:			byte;
	=9B
}

layout struct bend for "GP5"{
	def _size(){
		return list_points.length * 9 + 9;
	}
	+0B			bend_type:			byte;
	// Bend height. It is 100 per tone and goes by quarter tone
	+1B			value:				int;
	// Number of points used to display the bend. Is followed by the list of points
	+5B			num_point:			int;
	// List of points, an array of points
	+9B			list_points:			Array<point>;
	=_size();
}

layout struct effect_on_beats for "GP5"{
	def _size(){
		return 5 + tremolo_bar._size();
	}
	+0B			header:				byte;
	// The presence of this effect is set by the bit 5 of the first header byte
	// 0: None, 1: Tapping, 2: Slapping, 3: Popping
	+1B			TSP:				byte;
	// The presence of this effect is set by the bit 2 of the second header byte
	+2B			tremolo_bar:			bend;
	__			upstroke:			byte;
	__			downstroke:			byte;
	__			pickstroe:			byte;
	=_size();
}

layout struct mix_table_change_event for "GP5"{
	def _size(){
		return 18;
	}
	// Gives the number of the new instrument. The value is -1 if no instrument change occurs
	+0B			instrument:			byte;
	// Gives the new volume value. The value is -1 if no volume change occurs
	+1B			volume:				byte;
	// Gives the new pan value. The value is -1 if no pan change occurs
	+2B			pan:				byte;
	// Gives the new chorus value. The value is -1 if no chorus change occurs
	+3B			chorus:				byte;
	// Gives the new reverb value. The value is -1 if no reverb change occurs
	+4B			reverb:				byte;
	// Gives the new phaser value. The value is -1 if no phaser change occurs
	+5B			phaser:				byte;
	// Gives the new tremolo value. The value is -1 if no tremolo change occurs
	+6B			tremolo:			byte;
	// Gives the new tempo value. The value is -1 if no tempo change occurs
	+7B			tempo:				int;
	// Gives the volume change duration in beats
	+11B			volume_change:			byte;
	// Gives the pan change duration in beats
	+12B			pan_change:			byte;
	// Gives the chorus change duration in beats
	+13B			chorus_change:			byte;
	// Gives the reverb change duration in beats
	+14B			reverb_change:			byte;
	// Gives the phaser change duration in beats
	+15B			phaser_change:			byte;
	// Gives the tremolo change duration in beats
	+16B			tremolo_change:			byte;
	// Gives the tempo change duration in beats
	+17B			tempo_change:			byte;
	// The next byte precises if the changes apply only to the current track (if the 
	// matching bit is 0), or to every track (if it is 1)
	+18B			apply:				byte;
	=18B;
}

layout struct grace_note for "GP5"{
	def _size(){
		return 4;
	}
	+0B			fret:				byte;
	+1B			dynamic:			byte;
	+2B			transition:			byte;
	+3B			duration:			byte;
	=4B
}

layout struct effect_on_notes for "GP5"{
	def _size(){
		return 7 + 4 + a_bend._size();
	}
	+0B			header:				byte[2];
	// If the bit 0 of the first header byte is true, we write here the bend 
	+1B			a_bend:				bend;
	// If the bit 4 of the first header byte is true, we write here the data
	// relative to the Grace Note
	__			g_note:				grace_note;
	// If the bit 2 of the second header byte is true, the information linked to
	// tremolo picking are saved here
	__ 			tremolo_picking:		byte;
	// If the bit 3 of the second header byte is true, the information linked to
	// the slide is stored here
	__			slide:				byte;
	// If the bit 4 of the second header byte is true, the information linked to
	// the harmonics is stored here
	__			harmonics:			byte;
	// If the bit 5 of the second header byte is true, the information linked to
	// the Trill effect is stored here
	__			trill_effect:			byte[2];
	=_size();
}

layout struct note for "GP5"{
	def _size(){
		return 9 + effect_on_notes.size();
	}
	+0B			header:				byte;
	// If the bit 5 is true, we start by writing the note type
	+1B			note_type:			byte[2];
	// If the bit 0 is true, we write the 2 following information linked to the note duration
	+3B			time_duration:			byte;
	+4B			n_tuplet:			byte;
	// If the bit 4 of the header byte is true, we write here the note strength
	+5B			note_dynamic:			byte;
	// If the bit 5 is true, we write here the number of the fret on which the note is applied
	+6B			fret_number:			byte;
	// If the bit 7 is true, we write here successively the fingerings left hand,
	// then right hand, each of them being written on one byte
	+7B			fingering:			byte[2];
	+9B			eff_on_note:			effect_on_notes;
	=_size();
}

layout struct beat for "GP5"{
	+0B			header:				byte;
	// If the bit 6 of header is true, we start by writing the beat status. The value is
	// 0x00 if the beat is empty and 0x02 if it is a rest.
	+1B			status:				byte;
	// Duration: written in num of eighth note
	+2B			beat_duration:			byte;
	// If the bit 5 of header is true, this integer corresponds to the
	// 'n' in 'n-tuplet': 3, 5, 6, 7, 9, 10, 11, 12 and 13.
	+3B			n_tup:				int;
	// If the presence of a chord diagram is indicated by the bit 1 of the
	// header, it is then written here: which means that it is optional 
	+7B			OPT_chord_d:			chord_diagram;
	// If the presence of a text is indicated by the bit 2 of the header, it is
	// written here
	__			text:				IntSizedString;
	// If the presence of an effect is indicated by the bit 3 of the header, it
	// is written at this place
	__ 			effect:				effect_on_beats;
	// If the presence of an event linked to the mix table is indicated by the
	// bit 4 of the header, it is written here
	__			mtb_cevent:			mix_table_change_event;
	// The note itself is written here
	__			notes:				note;
}

layout struct Body for "GP5"{
	def _size(){
		int sum = 0;
		// TODO: syntax for automatically sum all sizes listed below
		for (...){
			sum += ...
		}
		return sum;
	}
	def measures_size(){
	// A size() function specifically for measures
		int sum = 0;
		for (msr in msrs){
			sum += msr._size();
		}
		return sum;
	}
	def array_size(array_obj: Array<obj>){
	// Or alternatively, we can make the array size function generic?
		int sum = 0;
		for (item in array_obj){
			sum += item._size();
		}
		return sum;
	}
	// An array of measures written one after another
	+0B			msrs:				Array<measure>		size = measures_size(); // Shall we add an extra line?
	// TODO: we will want the parser know to call measures_size() here
	__			tracks:				Array<track>		size = array_size(tracks);
	// Pairs of measure and beat track
	__			msr_bt_track:			measure_beat_track	size = measure_beat_track._size();
	__			beats:				Array<beat>		size = arary_size(beats);
	=_size();
}